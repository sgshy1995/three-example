<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - exporter - ply</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="./css/main.css">
</head>
<body>
<div id="info">
    <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - exporter - ply
</div>

<!-- Import maps polyfill -->
<!-- Remove this when import maps will be widely supported -->
<script async src="./lib/es-module-shims.js"></script>

<script type="importmap">
			{
				"imports": {
					"three": "./lib/three.module.js"
				}
			}

</script>

<script type="module">

    import * as THREE from 'three';

    import {OrbitControls} from './lib/jsm/controls/OrbitControls.js';
    import {PLYExporter} from './lib/jsm/exporters/PLYExporter.js';
    import {GUI} from './lib/jsm/libs/lil-gui.module.min.js';

    let scene, camera, renderer, exporter, mesh;

    const params = {
        exportASCII: exportASCII,
        exportBinaryBigEndian: exportBinaryBigEndian,
        exportBinaryLittleEndian: exportBinaryLittleEndian
    };


    init();
    animate();

    function init() {

        /**
         * THREE.PerspectiveCamera(fov : Number, aspect : Number, near : Number, far : Number)
         * fov -- Camera frustum vertical field of view 相机视锥垂直视野
         * aspect -- Camera frustum aspect ratio 相机截锥纵横比
         * near -- Camera frustum near plane 摄像机近平面截锥
         * far -- Camera frustum far plane 摄像机远平面截锥
         * */
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.set(200, 100, 200);

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xa0a0a0);
        scene.fog = new THREE.Fog(0xa0a0a0, 200, 1000);

        exporter = new PLYExporter();

        //

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
        hemiLight.position.set(0, 200, 0);
        scene.add(hemiLight);

        // 投影绘制
        const directionalLight = new THREE.DirectionalLight(0xffffff);
        directionalLight.position.set(0, 200, 100);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.top = 180;
        directionalLight.shadow.camera.bottom = -100;
        directionalLight.shadow.camera.left = -120;
        directionalLight.shadow.camera.right = 120;
        scene.add(directionalLight);

        // ground
        // 地板绘制
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), new THREE.MeshPhongMaterial({
            color: 0x999999,
            depthWrite: false
        }));
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // 地板格绘制
        const grid = new THREE.GridHelper(2000, 20, 0x000000, 0x000000);
        grid.material.opacity = 0.05;
        grid.material.transparent = true;
        scene.add(grid);

        // export mesh

        // 长方体绘制 宽  高  长
        const geometry = new THREE.BoxGeometry(50, 50, 100);
        // 彩色
        // const material = new THREE.MeshPhongMaterial( { vertexColors: true } );
        const material = new THREE.MeshPhongMaterial({
            color: 'rgba(6,63,155,0.2)',
            transparent: true,
            // 设置材质透明度
            opacity: 0.2
        });


        // color vertices based on vertex positions
        const colors = geometry.getAttribute('position').array.slice();
        for (let i = 0, l = colors.length; i < l; i++) {

            if (colors[i] > 0) colors[i] = 0.5;
            else colors[i] = 0;

        }

        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3, false));

        mesh = new THREE.Mesh(geometry, material);
        mesh.castShadow = true;
        mesh.position.y = 25;
        scene.add(mesh);

        //

        /**
         * 阵列立方体网格模型
         */
        // 一排一排
        function drawCubesByRow() {
            var box = new THREE.BoxGeometry(10, 10, 10);//创建一个立方体几何对象
            var material1 = new THREE.MeshLambertMaterial({color: 'yellow'});//材质对象
            var meshAdd = new THREE.Object3D();//创建Object3D对象
            for (var z = 0; z < 2; z++) {//10表示z方向立方体数量
                for (var y = 0; y < 2; y++) {//10表示y方向立方体数量
                    for (var x = 0; x < 2; x++) {//10表示x方向立方体数量
                        var mesh1 = new THREE.Mesh(box, material1);//网格模型对象
                        mesh1.position.set(x * 10, y * 10, z * 10);//立方体间距15（阵列距离）
                        meshAdd.add(mesh1);//网格模型添加到场景中
                        // 立方体几何体box作为EdgesGeometry参数创建一个新的几何体
                        var edges = new THREE.EdgesGeometry(box);
                        var edgesMaterial = new THREE.LineBasicMaterial({
                            color: '#333'
                        })
                        var line = new THREE.LineSegments(edges, edgesMaterial);
                        line.position.set(x * 10, y * 10, z * 10);//立方体间距15（阵列距离）
                        meshAdd.add(line);//网格模型添加到场景中
                    }
                }
            }
            meshAdd.position.y = 25;//平移所有网格模型
            scene.add(meshAdd);//网格模型添加到场景中
        }

        drawCubesByRow()


        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        //

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 25, 0);
        controls.update();

        //

        window.addEventListener('resize', onWindowResize);

        const gui = new GUI();

        gui.add(params, 'exportASCII').name('Export PLY (ASCII)');
        gui.add(params, 'exportBinaryBigEndian').name('Export PLY (Binary BE)');
        gui.add(params, 'exportBinaryLittleEndian').name('Export PLY (Binary LE)');
        gui.open();

    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);

    }

    function animate() {

        requestAnimationFrame(animate);
        renderer.render(scene, camera);

    }

    function exportASCII() {

        exporter.parse(mesh, function (result) {

            saveString(result, 'box.ply');

        });

    }

    function exportBinaryBigEndian() {

        exporter.parse(mesh, function (result) {

            saveArrayBuffer(result, 'box.ply');

        }, {binary: true});

    }

    function exportBinaryLittleEndian() {

        exporter.parse(mesh, function (result) {

            saveArrayBuffer(result, 'box.ply');

        }, {binary: true, littleEndian: true});

    }

    const link = document.createElement('a');
    link.style.display = 'none';
    document.body.appendChild(link);

    function save(blob, filename) {

        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();

    }

    function saveString(text, filename) {

        save(new Blob([text], {type: 'text/plain'}), filename);

    }

    function saveArrayBuffer(buffer, filename) {

        save(new Blob([buffer], {type: 'application/octet-stream'}), filename);

    }

</script>

</body>
</html>
